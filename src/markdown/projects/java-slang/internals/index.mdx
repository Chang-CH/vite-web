# Understanding the Java Virtual Machine

The JVM consists of a few main components:

1. **Class Loader**: Loads class files into memory.
2. **Memory Area**: Where data is stored, from the stack to the heap to the method area.
3. **Execution Engine**: Executes the bytecode.
4. **Native Method Interface**: Allows the JVM to interact with the host system.

Note that the actual implementation of the JVM need not follow the exact same structure as above.
For example, the method area is often combined with the heap in practice, albeit sometimes with special garbage collection rules.

## The Java Classfile

Let's start with a simple hello world program:

```java
// HelloWorld.java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
```

When we compile this code with `javac HelloWorld.java -target 8 -source 8` (to target java version 8), and we get a classfile, `HelloWorld.class`. This classfile contains the bytecode of the program.

## The Bootstrap Class Loader

Before we can run the program, we have a few classes to load and initialize. Think the main `Thread` object, or the `ClassLoader` object.

How do we load class files when class loaders are Java objects themselves? Enter the bootstrap class loader.
Also known as the primordial class loader, the bootstrap class loader is a native class loader that is responsible for loading the core Java classes.
Unlike other class loaders, the bootstrap class loader has no parent class loaders.

When a class is requested, a class loader does the following:

1. Pass the request to its parent class loader.
2. If the parent class loader is unable to load the class (or if there is no parent loader), attempt to load the class in its own class path.
3. [Optional] Link the class (verify the binary, resolve symbolic references, etc).
   The JVM may choose to do this step eagerly (at load time), or lazily (when the symbolic reference is used).
   Even if the JVM links eagerly, exceptions during resolution will only be thrown when the symbolic reference is used.

Fun fact, the same class, loaded by different class loaders, is considered different by the JVM.
For `java-slang`, this is implemented by having each class loader store a `loadedClasses` object, which maps class names to class data.

## Initializing the JVM

With the bootstrap class loader in place, we can now initialize the JVM. This step is implementation dependent, and for `java-slang`, it looks something like this:

1. load essential classes: `Object`, `Class`, `Thread`, `Unsafe`, `System`, etc.
2. Initialize the `ThreadGroup` class, then the `Thread` class by calling their `<clinit>` static initializer.
3. Instantiate the `ThreadGroup` object, then the `Thread` object by calling their `<init>` initializer.
4. Set the `group` field of the thread object to the threadgroup, and the `priority` field.
5. Initialize the `System` class by calling its static method `initializeSystemClass()`. This is separate from its `<clinit>` method.
6. Initialize the system class loader by calling the `getSystemClassLoader()` method of the `ClassLoader` class.

## Running the Program

Now that we are set, we can run the program. This means loading and initializing the compiled `HelloWorld.class` file
using the system class loader, and executing the `main` method.

After compilation, the `main` method is now a series of bytecode instructions. We can view this by running `javap -v -p -c HelloWorld.class`:

```
0: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;
3: ldc           #13                 // String Hello, World!
5: invokevirtual #15                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
8: return
```

To execute these instructions, we rely on the execution engine, which is really just a while loop. It does the following:

1. read the instruction at the current program counter (pc).
2. perform the action.
3. If there is no exception, increment the pc.
