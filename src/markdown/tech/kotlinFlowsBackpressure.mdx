---
title: 'Kotlin Flow Backpressure Handling'
description: 'Handling backpressure in Kotlin flows'
tags: ['android', 'kotlin']
---

# Kotlin Flow Backpressure Handling

Kotlin flows are powerful tools for handling asynchronous data streams in Android development.

This article focuses on how to handle backpressure in Kotlin flows -- situations when the producer emits
values faster than some consumer can process them.

## Conflate

`Flow.conflate()` returns a conflated flow. This is equivalent to calling `buffer(capacity = 0, onBufferOverflow = BufferOverflow.DROP_OLDEST)`.
Notice that this is exactly how `StateFlow`s are set up! Once again, this ensures the emitter is not suspended,
and when the slow collector is ready to collect the next value, it will simply collect the latest value available.

```kotlin
flow {
    for (i in 1..10) {
        delay(500)
        emit(i)
    }
}
    .conflate()
    .collect { value ->
        println(value)
        delay(1000) // Simulate slow collector
        println(value)
    }
```

This will output:

```
1
3
5
...
```

## Buffer

`Flow.buffer()` allows you to specify a buffer size for the flow.
This means that the flow can hold a certain number of values before it starts dropping them or
suspending the emitter.

```kotlin
flow {
    for (i in 1..3) {
        println("Emitting: $i")
        delay(100)
        emit(i)
    }
}
    .buffer(5) // Buffer size of 5
    .collect { value ->
        println("start: $value")
        delay(1000) // Simulate slow collector
        println("end: $value")
    }
```

This will output:

```
Emitting: 1
start: 1
Emitting: 2
Emitting: 3
end: 1
start: 2
end: 2
start: 3
end: 3
```

We can also configure the buffer strategy using the `onBufferOverflow` parameter.

1. `BufferOverflow.SUSPEND`: The **DEFAULT** strategy. Emitter will **suspend until all collectors are ready** to collect the next value. This can cause slow UI updates!
2. `BufferOverflow.DROP_OLDEST`: The oldest value in the buffer will be dropped if the buffer is full.
3. `BufferOverflow.DROP_LATEST`: Rarely used, the latest value will be dropped if the buffer is full.

Let us take a look at an example using `BufferOverflow.SUSPEND`:

```kotlin
flow {
    for (i in 1..3) {
        println("Begin Emission: $i")
        delay(500)
        emit(i)
        println("Emitted: $i")
    }
}
    .buffer(capacity = 1, onBufferOverflow = BufferOverflow.SUSPEND)
    .collect { value ->
        println("start: $value")
        delay(1000) // Simulate slow collector
        println("end: $value")
    }
```

This will output:

```
Begin Emission: 1
Emitted: 1
Begin Emission: 2 // 2 enters buffer, buffer is full
start: 1
Emitted: 2
Begin Emission: 3 // 3 cannot enter buffer, emit(3) is paused
end: 1
start: 2 // 2 is collected, buffer is now empty
Emitted: 3 // 3 enters buffer
end: 2
start: 3
end: 3
```

Now, on to `BufferOverflow.DROP_OLDEST`:

```kotlin
flow {
    for (i in 1..3) {
        println("Begin Emission: $i")
        delay(500)
        emit(i)
        println("Emitted: $i")
    }
}
    .buffer(capacity = 1, onBufferOverflow = BufferOverflow.DROP_OLDEST)
    .collect { value ->
        println("start: $value")
        delay(1000) // Simulate slow collector
        println("end: $value")
    }
```

This will output:

```
Begin Emission: 1
Emitted: 1
Begin Emission: 2 // 2 enters buffer, buffer is full
start: 1
Emitted: 2
Begin Emission: 3
Emitted: 3 // 3 evicts oldest value (2) from buffer
end: 1
start: 3 // collector collects the next item in the buffer, 3
end: 3
```

### Practical application

1. `SharedFlow` uses a buffer size of `0` and strategy `SUSPEND` by default. If we do not mind dropping values
   and instead prioritise not suspending the emitter, use `DROP_OLDEST` instead.

```kotlin
val flow = MutableSharedFlow<Int>()

val job1 = launch{
    flow.collect { value ->
        println("job1 start: $value")
        delay(100) // Simulate slow collector
        println("job1 end: $value")
    }
}

val job2 = launch{
    flow.collect { value ->
        println("job2 start: $value")
        delay(300) // Simulate slow collector
        println("job2 end: $value")
    }
}

launch{
    for (i in (1..3)) {
        println("Begin Emission: $i")
        flow.emit(i)
        println("Emitted: $i")
    }
    job1.cancel()
    job2.cancel()
}
```

This will output:

```sh
Begin Emission: 1
job1 start: 1
job2 start: 1
Emitted: 1
Begin Emission: 2
job1 end: 1
job1 start: 2
job1 end: 2
job2 end: 1
job2 start: 2
# producer context has to suspend until job2 consumes 2,
# even if job1 can consume 3 already.
Emitted: 2
Begin Emission: 3
job1 start: 3
job1 end: 3
job2 end: 2
job2 start: 3
Emitted: 3
```

Notice how the producer has to wait for all collectors to consume the value before it can emit the next one.
Even though `job1` can consume the next value, the producer has to wait for `job2` to finish consuming the previous value.

## CollectLatest

`Flow.collectLatest()` is another way to handle backpressure.
It collects the latest value emitted by the flow and cancels the previous collection if it is still in progress.

```kotlin
flow {
    for (i in 1..10) {
        delay(500)
        emit(i)
    }
}
    .collectLatest { value ->
        println("start: $value")
        delay(1000) // Simulate slow collector
        println("end: $value")
    }
```

This will output:

```
start: 1
start: 2
start: 3
...
start: 10
end: 10
```

Unlike `conflate`, any currently running collection may not complete before the next value is emitted.

## debounce

`Flow.debounce()` is used to delay the emission of values until a certain time has passed without any
new values being emitted. It works somewhat similar to collectLatest. When a debounced flow collects a value,
it waits for a specified time before emitting it. If a new value is emitted during this time, the
previous value is discarded, and the timer resets.

## throttleFirst

`Flow.throttleFirst()` is used to limit the rate at which values are emitted from a flow.
Unlike `debounce`, which waits for a period of inactivity, `throttleFirst` emits the first value
immediately and then ignores subsequent values for a specified duration.

## sample

`Flow.sample()` is used to emit the latest value from a flow at regular intervals.

# Playground

Here's a simple setup you can run on [kotlin playground](https://play.kotlinlang.org/) to see how backpressure works in practice.

```kotlin
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.channels.BufferOverflow
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.asSharedFlow
import kotlinx.coroutines.flow.collect
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.flow.receiveAsFlow

fun simple(): Flow<Int> = flow {
    for (i in 1..3) {
        println("Begin Emission: $i")
        delay(50)
        emit(i)
        println("Emitted: $i")
    }
}

fun main() = runBlocking<Unit> {
    val job1 = launch{
        flow.conflate().collect { value ->
            println("job1 start: $value")
            delay(100) // Simulate slow collector
            println("job1 end: $value")
        }
    }

    val job2 = launch{
        flow.conflate().collect { value ->
            println("job2 start: $value")
            delay(300) // Simulate slow collector
            println("job2 end: $value")
        }
    }

    launch{
        for (i in (1..5)) {
            println("Begin Emission: $i")
            flow.emit(i)
            delay(50)
            println("Emitted: $i")
        }
        job1.cancel()
        job2.cancel()
    }
}
```

# References

1. [Handling Backpressure in Kotlin Flows](https://medium.com/@yash30401/handling-backpressure-in-kotlin-flows-buffer-conflate-collectlatest-debounce-sample-and-373222f7c1e1)
